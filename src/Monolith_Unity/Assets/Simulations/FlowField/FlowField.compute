#pragma kernel UpdateParticles
#pragma kernel Fade
#pragma kernel RenderFBM

struct Particle
{
    float2 pos;
    float2 vel;
};

RWTexture2D<float4> Result;

StructuredBuffer<Particle> particlesRead;
RWStructuredBuffer<Particle> particlesWrite;
StructuredBuffer<float4> palette;

cbuffer Params
{
    float2 resolution;
    float time;
    float deltaTime;

    int octaveCount;
    float frequency;
    float lacunarity;
    float gain;
    float curlStrength;
    float speed;
    float fade;
    int paletteSize;
    float particleSize;
};


// ---------------------------
// 3D Perlin noise (evolving)
// ---------------------------
float3 randomGradient(int3 p)
{
    uint x = (uint) p.x * 374761393u + (uint) p.y * 668265263u + (uint) p.z * 912367421u;
    x = (x ^ (x >> 13)) * 1274126177u;
    float angle = frac(x / 4294967296.0) * 6.2831853;
    float z = frac(sin(x) * 43758.5453) * 2 - 1; // small z component
    return normalize(float3(cos(angle), sin(angle), z));
}

float Perlin(float3 p)
{
    int3 i = int3(floor(p));
    float3 f = frac(p);

    float3 g000 = randomGradient(i + int3(0, 0, 0));
    float3 g100 = randomGradient(i + int3(1, 0, 0));
    float3 g010 = randomGradient(i + int3(0, 1, 0));
    float3 g110 = randomGradient(i + int3(1, 1, 0));
    float3 g001 = randomGradient(i + int3(0, 0, 1));
    float3 g101 = randomGradient(i + int3(1, 0, 1));
    float3 g011 = randomGradient(i + int3(0, 1, 1));
    float3 g111 = randomGradient(i + int3(1, 1, 1));

    float3 d000 = f - float3(0, 0, 0);
    float3 d100 = f - float3(1, 0, 0);
    float3 d010 = f - float3(0, 1, 0);
    float3 d110 = f - float3(1, 1, 0);
    float3 d001 = f - float3(0, 0, 1);
    float3 d101 = f - float3(1, 0, 1);
    float3 d011 = f - float3(0, 1, 1);
    float3 d111 = f - float3(1, 1, 1);

    float s000 = dot(g000, d000);
    float s100 = dot(g100, d100);
    float s010 = dot(g010, d010);
    float s110 = dot(g110, d110);
    float s001 = dot(g001, d001);
    float s101 = dot(g101, d101);
    float s011 = dot(g011, d011);
    float s111 = dot(g111, d111);

    float3 u = f * f * (3 - 2 * f);

    float nx00 = lerp(s000, s100, u.x);
    float nx01 = lerp(s001, s101, u.x);
    float nx10 = lerp(s010, s110, u.x);
    float nx11 = lerp(s011, s111, u.x);

    float nxy0 = lerp(nx00, nx10, u.y);
    float nxy1 = lerp(nx01, nx11, u.y);

    float nxyz = lerp(nxy0, nxy1, u.z);

    return nxyz;
}

float FBM(float2 p, float t)
{
    float value = 0;
    float amp = 1;
    float freq = frequency;

    for (int i = 0; i < octaveCount; i++)
    {
        value += Perlin(float3(p * freq, t * 0.1)) * amp;
        freq *= lacunarity;
        amp *= gain;
    }
    return value;
}

// ---------------------------
// Curl noise (2D vector field)
// ---------------------------
float2 CurlNoise(float2 p, float t)
{
    float eps = 0.01;

    float n1 = FBM(p + float2(0, eps), t);
    float n2 = FBM(p - float2(0, eps), t);
    float a = (n1 - n2) / (2 * eps);

    float n3 = FBM(p + float2(eps, 0), t);
    float n4 = FBM(p - float2(eps, 0), t);
    float b = (n3 - n4) / (2 * eps);

    return float2(a, -b);
}

// ---------------------------
// Particle update
// ---------------------------
[numthreads(256, 1, 1)]
void UpdateParticles(uint id : SV_DispatchThreadID)
{
    Particle p = particlesRead[id];

    float2 uv = p.pos / resolution;
    float2 flow = CurlNoise(uv, time) * curlStrength;

    // Smoothly follow the curl field
    p.vel = lerp(p.vel, flow * speed, deltaTime * curlStrength);

    // Small random jitter to avoid clustering
    float2 randDir = float2(
        frac(sin(dot(p.pos.xy + time, float2(12.9898, 78.233))) * 43758.5453) - 0.5,
        frac(sin(dot(p.pos.yx - time, float2(93.9898, 67.345))) * 43758.5453) - 0.5
    );
    p.vel += randDir * 0.1;

    // Damping
    p.vel *= 0.95;
    p.pos += p.vel * deltaTime;

    // Wrap edges
    if (p.pos.x < 0)
        p.pos.x += resolution.x;
    if (p.pos.y < 0)
        p.pos.y += resolution.y;
    if (p.pos.x >= resolution.x)
        p.pos.x -= resolution.x;
    if (p.pos.y >= resolution.y)
        p.pos.y -= resolution.y;

    particlesWrite[id] = p;

    // --- Color based on particle ID ---
    int index = id % paletteSize; // loop if more particles than colors
    float4 col = palette[index];

    int radius = (int) particleSize;

    for (int y = -radius; y <= radius; y++)
    {
        for (int x = -radius; x <= radius; x++)
        {
            int2 pixel = int2(p.pos) + int2(x, y);
            float dist = length(float2(x, y));
            if (dist <= radius)
            {
                Result[pixel] = col;
            }
        }
    }

}



// ---------------------------
// Fade trails
// ---------------------------
[numthreads(8, 8, 1)]
void Fade(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) resolution.x || id.y >= (uint) resolution.y)
        return;
    float4 col = Result[id];
    col *= fade;
    Result[id] = col;
}

// ---------------------------
// FBM visualization
// ---------------------------
[numthreads(8, 8, 1)]
void RenderFBM(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) resolution.x || id.y >= (uint) resolution.y)
        return;

    float2 uv = id / resolution;
    float val = FBM(uv, time); // evolving FBM
    val = saturate(val / octaveCount); // normalize to 0..1
    Result[id] = float4(val, val, val, 1);
}
