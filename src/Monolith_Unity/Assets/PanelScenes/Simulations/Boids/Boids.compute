#pragma kernel UpdateBoids
#pragma kernel FadeTrails
#pragma kernel DrawTrails

struct Boid
{
    float2 position;
    float2 velocity;
};

RWStructuredBuffer<Boid> boids;
RWTexture2D<float4> Result;

uint boidCount;
float deltaTime;
float2 resolution;

// Boids parameters
float neighborRadius;
float separationRadius;
float maxSpeed;
float alignmentWeight;
float cohesionWeight;
float separationWeight;

// Trail parameters
float trailFade; // 0.0 = infinite trail, 1.0 = instant fade
float trailRadius;
bool renderBoids;

StructuredBuffer<float4> palette;
uint paletteCount;


float4 GetBoidColor(uint id)
{
    if (paletteCount == 0)
        return float4(1, 1, 1, 1);

    float t = (float) id / (float) boidCount;
    float scaled = t * paletteCount;

    uint i0 = (uint) floor(scaled) % paletteCount;
    uint i1 = (i0 + 1) % paletteCount;
    float f = frac(scaled);

    return lerp(palette[i0], palette[i1], f);
}


[numthreads(256, 1, 1)]
void UpdateBoids(uint id : SV_DispatchThreadID)
{
    if (id >= boidCount)
        return;

    Boid self = boids[id];

    float2 alignment = 0;
    float2 cohesion = 0;
    float2 separation = 0;
    int count = 0;

    for (uint i = 0; i < boidCount; i++)
    {
        if (i == id)
            continue;

        Boid other = boids[i];
        float2 diff = other.position - self.position;

        // Wrap distance (toroidal space)
        if (diff.x > resolution.x * 0.5)
            diff.x -= resolution.x;
        if (diff.x < -resolution.x * 0.5)
            diff.x += resolution.x;
        if (diff.y > resolution.y * 0.5)
            diff.y -= resolution.y;
        if (diff.y < -resolution.y * 0.5)
            diff.y += resolution.y;

        float distSq = dot(diff, diff);
        if (distSq < neighborRadius * neighborRadius)
        {
            float dist = length(diff);
            if (dist < neighborRadius)
            {
                alignment += other.velocity;
                cohesion += other.position;
                count++;

                if (dist < separationRadius)
                    separation -= diff / max(dist, 0.001);
            }
        }
    }

    if (count > 0)
    {
        alignment = normalize(alignment / count) * alignmentWeight;
        cohesion = ((cohesion / count) - self.position) * cohesionWeight;
        separation *= separationWeight;
    }

    self.velocity += alignment + cohesion + separation;

    float speed = length(self.velocity);
    if (speed > maxSpeed)
        self.velocity = normalize(self.velocity) * maxSpeed;

    self.position += self.velocity * deltaTime;

    // Screen wrap
    if (self.position.x < 0)
        self.position.x += resolution.x;
    if (self.position.y < 0)
        self.position.y += resolution.y;
    if (self.position.x > resolution.x)
        self.position.x -= resolution.x;
    if (self.position.y > resolution.y)
        self.position.y -= resolution.y;

    boids[id] = self;
}

[numthreads(8, 8, 1)]
void FadeTrails(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) resolution.x || id.y >= (uint) resolution.y)
        return;

    float4 c = Result[id];
    c.a *= (1.0 - trailFade);
    Result[id] = c;
}

[numthreads(256, 1, 1)]
void DrawTrails(uint id : SV_DispatchThreadID)
{
    if (id >= boidCount)
        return;

    float2 pos = boids[id].position;
    float4 color = GetBoidColor(id);

    for (int x = -trailRadius; x <= trailRadius; x++)
    {
        for (int y = -trailRadius; y <= trailRadius; y++)
        {
            float2 p = pos + float2(x, y);
            if (p.x < 0 || p.y < 0 || p.x >= resolution.x || p.y >= resolution.y)
                continue;

            float d = length(float2(x, y));
            if (d > trailRadius)
                continue;

            Result[p] = color;
        }
    }
}

